
# 57. ライフサイクル

Reactの関数コンポーネントで非同期処理や非同期通信を行う際に便利なフックである `useEffect` を理解するため、まずコンポーネントのライフサイクルについて解説します。

## ライフサイクルとは？

- コンポーネントが「表示される（マウント）」「更新される（アップデート）」「破棄される（アンマウント）」一連の流れを指す。
    

### ライフサイクルのフェーズ

1. **マウント（Mount）**
    
    - コンポーネントが初めて画面に表示されるタイミング。
        
    - `constructor` → `render` → DOM更新 → 「マウントされた」状態になる。
        
    - DOMが更新された後に処理を行う必要があり、ここで非同期通信を実行するのが一般的。
        
2. **更新（Update）**
    
    - `state`や`props`が変わったとき、親コンポーネントが更新されたときなどに発生。
        
    - 再レンダリングが行われた後、DOMが更新されて「アップデートされた」状態になる。
        
3. **アンマウント（Unmount）**
    
    - コンポーネントが画面から取り除かれるタイミング。
        

## 重要なポイント

- DOMが生成・更新された後に非同期通信や副作用を起こす処理を実行する必要がある。
    
- Reactの `useEffect` フックは、このマウント後や更新後のタイミングで処理を実行するための仕組み。
    

---

次の動画で `useEffect` の具体的な使い方を解説します。まずはライフサイクルの流れをイメージしておいてください。

# 58. useEffect() とエフェクトについて解説します

## エフェクトとは？

- 「効果」「影響作用」の意味で、Reactでは「副作用フック」と呼ばれる。
- クラスコンポーネントのライフサイクルメソッドに似ており、コンポーネントのマウント・アップデート後に処理を実行できる。
- Reactの `useEffect` フックを使って非同期通信やDOM操作、タイマー設定などを行う。

## useEffectの使い方

- `useEffect` は2つの引数を取る。
    1. **コールバック関数**
        - 実行したい処理を記述。
        - コールバック内で`return`に関数を書くと、それは「クリーンアップ関数」として扱われ、次の更新前に実行される。
        - クリーンアップは前回の副作用を解除・初期化するために重要（例：`setInterval`の解除など）。
    2. **依存配列**
        - 依存する値を配列で指定。
        - 配列内の値が変化したときのみ副作用を再実行。
        - 空配列 `[]` を指定すると、初回マウント時のみ実行される。
        - 依存配列を書かないと、毎レンダリングごとに実行されてしまい、無限ループになる可能性がある。

## 実例と動作

- 例として、`useState` でカウント管理し、`useEffect` でカウントの変化に応じた処理を実行。
- コンソールにレンダリング・副作用の実行・クリーンアップのログを出すことで動作確認できる。
- 依存配列を空にすると副作用は初回のみ、外すと毎回実行される。
- 依存配列に特定のステート変数を入れると、その変数が変わった時だけ副作用が実行される。

## 注意点

- クリーンアップ関数は、再レンダリングの前やアンマウント時に副作用を解除するため必須のケースが多い。
- 無限ループを防ぐために依存配列は必ず設定し、必要な依存だけを入れること。

---

この内容を踏まえて、実際にコードを書きながら`useEffect`の動きを体感すると理解が深まります。

# 59. サンプル5: API情報取得（犬の画像を取得）

## 概要

- Reactで`useEffect`を使い、外部API（ドッグAPI）から犬の画像を取得して表示するサンプルアプリを作成。
    
- 以前JavaScriptやVue.jsで実施した内容をReactでも同様に実装。
    

## ドッグAPIについて

- URL: `https://dog.ceo/api/breeds/image/random`
    
- ランダムな犬の画像URLをJSON形式で返すAPI。
    
- 返却データ例: `{ message: "画像URL", status: "success" }`
    

## 実装ポイント

1. **State管理**
    
    - 画像URLを保存するために`useState`で`image`と`setImage`を用意。
        
    - 初期値は空文字列。
        
2. **非同期通信**
    
    - 非同期関数`getDogImage`を定義（`async`関数、`await`で処理待ち）。
        
    - `fetch`でAPIをGETし、レスポンスをJSONに変換。
        
    - 取得した画像URLを`setImage`で更新。
        
3. **ボタンで画像取得**
    
    - ボタンのクリックイベントに`getDogImage`を紐づける。
        
    - ボタン押下で新しい犬画像が取得・表示される。
        
4. **初回自動取得**
    
    - `useEffect`を利用し、初回マウント時（空の依存配列`[]`）に`getDogImage`を実行して自動で画像を取得。
        

## 動作確認

- ブラウザでページを開き、ボタン押下で犬の画像が表示されることを確認。
    
- ページ更新時にも自動で画像が読み込まれる。
    

## ポイントまとめ

- 外部APIからデータを取得する際は非同期処理が必須。
    
- `async/await`と`fetch`を組み合わせて簡潔に記述可能。
    
- Reactの`useEffect`は初回処理の自動実行に便利。
    
- ステート更新後はUIが自動で再レンダリングされる。
    

---

このサンプルは外部API連携の基本的な流れを理解するのに役立ちます。

# 60. ToDoリストに検索機能を追加する

## 概要
- Reactの`useEffect`を使って、前回作成したToDoリストに検索機能を追加するサンプル。
- 入力ボックスに文字を入れると、その文字を含むToDoだけがリアルタイムに表示される。

## 実装ポイント

### Stateの追加
- `searchValue` と `setSearchValue`：検索ボックスの入力値を管理（初期値は空文字列）
- `filteredList` と `setFilteredList`：検索結果の配列を管理（初期値はToDoリストの配列）

### 入力ボックスの設置
- 検索用のインプットボックスを追加
- `value` に `searchValue` をセットし、`onChange`で`setSearchValue`を呼び出し入力値を更新

### 検索ロジック（`useEffect`内）
- 依存配列に`searchValue`を指定し、`searchValue`が変わるたびに処理を実行
- ToDoリスト配列を`filter`で絞り込み
  - 各ToDoアイテムのテキストに`searchValue`が含まれているかを判定（`indexOf`メソッド使用）
- 絞り込み結果を`setFilteredList`で更新

### 表示部分の条件分岐
- 検索文字列が空の場合は元のToDoリストを表示
- 検索文字列がある場合は`filteredList`を表示

## 注意点
- 元のToDoリスト配列を直接書き換えず、検索結果用の配列を別途用意して管理することで元データを保持
- `useEffect`の依存配列に検索文字列を正しく指定しないと無限ループの可能性あり

## 動作確認
- 入力ボックスに文字を入れると、その文字を含むToDoだけが表示される
- 文字を消すと元のToDoリスト全件が再表示される

---

このサンプルで`useEffect`の依存配列による動的実行の仕組みと、検索フィルターの実装を体験できます。

# 61. カルーセルに自動画像切り替え機能を追加する

## 概要
- Reactの`useEffect`を使い、カルーセル（スライドショー）に4秒ごとに自動で画像が切り替わる機能を実装するサンプル。
- JavaScriptの`setInterval`を利用して一定間隔で画像切り替え処理を実行。
- 正しく動作させるために、`useEffect`のクリーンアップ関数で`clearInterval`を呼び、前のタイマーを解除することが重要。

## 実装のポイント

### State管理
- `active`：現在表示している画像のインデックス（ステート変数）

### useEffectの使い方
- 第1引数にコールバック関数、第2引数に`active`を指定
- コールバック内で`setInterval`をセットし、4秒ごとに`nextImage`関数（画像インデックスを+1する）を呼び出す
- `setInterval`の返り値（タイマーID）を変数`interval`に保存

### クリーンアップ関数
- `useEffect`のコールバック内で`return`に関数を返す形で記述
- その中で`clearInterval(interval)`を呼び出し、タイマーをクリアする
- これにより再レンダリング時に古いタイマーが残るのを防ぎ、重複実行を防止

## 注意点
- クリーンアップしないとタイマーが重複し、処理が複数回走る（指数関数的に増える）問題が発生する
- 第2引数の依存配列を正しく設定しないと動作が不安定になる

## 動作確認
- ページを開くと最初の画像が表示される
- 4秒ごとに`active`が更新され、次の画像に切り替わる
- ボタンなどで画像を手動切り替えしても4秒タイマーがリセットされ、その後また4秒ごとに切り替わる

---

`useEffect`で`setInterval`を使う場合は、必ずクリーンアップ関数で`clearInterval`を行い、不要なタイマーを解除することが安定動作のポイントです。


# 62. セクション5のまとめ

- ReactでAJAXや`setInterval`などの非同期処理・非同期通信を扱う際は、`useEffect`を使うとスムーズに動作させられる。
- `useEffect`はコンポーネントのライフサイクル（レンダー後に処理を実行）に合わせて動くため、DOM更新後の処理に適している。
- `useEffect`の使い方は少し複雑で、引数の指定やクリーンアップ処理を忘れると無限ループや動作不良（例：カルーセルが正しく動かない）などのバグが起こることがある。
- 特に初めは動作をよく確認しながら使うことが重要。
- 今回はCDNを使った環境で学習したが、次のセクションからはNPMを使ったより実践的な方法で進めていく予定。

引き続き講座を進めてください。
