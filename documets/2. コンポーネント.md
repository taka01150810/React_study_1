# 19. コンポーネントを作ってみる

---

## コンポーネントとは？

- 「部品」という意味で、Webページを複数の部品（コンポーネント）に分けて構成する。
- 複数ページで同じ部品を使い回せるため、メンテナンスがしやすく開発効率が上がる。
- コンポーネントは木構造で構成され、親コンポーネント→子コンポーネント→孫コンポーネントと階層的に管理される。

---

## Reactのコンポーネントの種類

- クラスコンポーネント（以前は主流だったが、現在は関数コンポーネントが主流）
- 関数コンポーネント（Hooksの登場で書きやすくなり主流に）

---

## 関数コンポーネントの作り方のポイント

- コンポーネント名は**必ず頭文字を大文字**（PascalCaseやUpperCamelCase）にする必要がある。
- 関数（Arrow関数やfunction）で作成し、`return`内でJSXを書く。
- 複数のJSXタグを返す場合は、**`<React.Fragment>` または空タグ `<> </>`** で囲む必要がある。

---

## コンポーネントの利用方法

- ルートの描画部分にコンポーネント名のタグを記述して呼び出す。
- `<ComponentName />` または `<ComponentName></ComponentName>` の形で書ける。


- 複数の同じコンポーネントを並べて使うことも可能。
- 複数の隣接タグは必ず一つの親タグ（フラグメントなど）で囲む必要がある。


---

## 実践例

- `const ComponentTest = () => { return ( <><div>コンポーネントです</div></> ); }`
- ルートに `<ComponentTest />` と書くと画面に表示される。

```
        const ComponentTest = () => {
            return (
                <>
                <div>コンポーネントです</div>
                </>
            )
        }

        root.render(<ComponentTest></ComponentTest>)

```

- 複数回書くことで同じコンポーネントを繰り返し表示できる。


```
        root.render(
            <>
            <ComponentTest></ComponentTest>
            <ComponentTest></ComponentTest>
            </>
        )
```


---

これらのポイントを踏まえ、関数コンポーネントを使った開発に慣れていきましょう。

# 20. Google Chrome拡張機能 (React Developer Tools)

---

## 概要

- Reactでコンポーネント化して画面を作る際に便利なChrome拡張機能「React Developer Tools」を紹介。
- ブラウザ上でReactコンポーネントの構造や状態を確認できる強力なツール。

---

## インストール手順

1. Google Chromeを開き、Chromeウェブストアで「React Developer Tools」を検索。
2. 「Chromeに追加」ボタンをクリックして拡張機能をインストール。
3. インストール完了後、ブラウザのパズルピースアイコンから「React Developer Tools」をピン留めしておくと便利。

---

## 設定の注意点

- Chromeの右上の「・・・」メニューから「その他のツール」→「拡張機能」を開く。
- 「React Developer Tools」の詳細ボタンをクリック。
- 「ファイルのURLへのアクセスを許可する」にチェックを入れる（これをしないとうまく機能しない）。
- Chromeを一度閉じて再起動する。

---

## 使い方

- Reactで作成したコンポーネントのあるページを開く。
- 右クリック→「検証」で開発者ツールを開く。
- タブに「Components」や「Profiler」が追加されているのが確認できる。
- 「Components」タブを選択すると、Reactコンポーネントの階層構造やprops、stateなどの情報が確認可能。

---

## ポイント

- コンポーネントの動作確認やデバッグに非常に便利。
- 今後プロップスや親子関係の管理などでも頻繁に使うため、先にインストールしておくことを推奨。

---

# 21. コンポーネントの親子関係

## 概要

- Reactのコンポーネントは親子関係で構成できる。
- 親コンポーネントの中に子コンポーネントを入れ、その子の中にさらに孫コンポーネントを作ることも可能。
- こうすることで画面構成を部品化し、管理しやすくできる。

---

## サンプルコードの流れ

1. **親コンポーネント（ParentComponent）**  
   - 関数コンポーネントで作成。  
   - JSXのリターン内に子コンポーネントを呼び出す。

2. **子コンポーネント（ChildComponent）**  
   - 関数コンポーネントで作成。  
   - 単純に「子供です」というテキストを表示。

3. **描画**  
   - ルートレンダーは親コンポーネントのみ指定。  
   - 親の中で子コンポーネントを使っているので、親子両方の内容が表示される。

---

## 実行結果

- ブラウザで「親です」「子供です」と表示される。
- ChromeのReact Developer Toolsでコンポーネントの階層が確認できる。

---

## ポイント

- コンポーネントを親子関係で作ることで画面の構造を分かりやすく保つ。
- 親の中に複数の子を入れたり、孫、ひ孫と深く作ることも可能。
- Reactの基本機能なので頻繁に使う。しっかり理解しておくことが重要。

---

# 22. props (親 -> 子 へデータを受け渡す)

---

## propsとは

- propsは「プロパティ」の略で、Reactコンポーネントに付随する属性や特性を意味する。
- 親コンポーネントから子コンポーネントへデータを渡すための仕組み。
- コンポーネント間の情報の受け渡しは直接できないが、propsを使うことで可能になる。

---

## 使い方のポイント

1. **親コンポーネントでの指定**  
   - 子コンポーネントを呼び出す際に属性名（例：`name`）を自由に設定し、値を渡す。

2. **子コンポーネントでの受け取り**  
   - 関数コンポーネントの引数に`props`と記述し、`props.name`で親から渡された値を取得・利用する。  
   - 例：`console.log(props)`で受け取った内容を確認可能。

3. **複数のデータを渡す**  
   - 例えば`name`と`email`を親から渡すこともできる。  
   - 子で`props.name`、`props.email`のようにアクセスし表示可能。

4. **propsの分割代入**  
   - 子コンポーネントの引数で波括弧を使い、`{ name, email }`のように分割代入で受け取る方法もある。  
   - これにより`props.name`の代わりに直接`name`でアクセス可能。

---

## 実行例

- 親で`<ChildComponent name="伊藤" email="test@test.com" />`と記述。  
- 子で`{ name, email }`を受け取り、画面に「伊藤」とメールアドレスを表示。  
- ChromeのReact Developer Toolsでpropsの中身を確認できる。

---

## まとめ

- Reactでは親から子へデータを渡すのにpropsを使うのが基本。  
- propsはコンポーネントの「入り口」として機能する。  
- 複数の値を渡せるし、分割代入で扱いやすくできる。  
- しっかり理解しておくとReact開発がスムーズになる。

---

# 23. propsで配列を渡す (子側で繰り返すパターン)

---

## 概要

- propsでは文字列や数字だけでなく、オブジェクトや配列も親から子に渡せる。
- 配列を渡し、子コンポーネントで配列の内容を表示・展開する方法を解説。
- 配列展開のパターンは大きく2つ：
  1. 子コンポーネント内で`map`メソッドを使い配列を展開するパターン
  2. 親コンポーネント側で`map`を使い、子コンポーネントを配列分繰り返すパターン（後述予定）

---

## サンプルの流れ

1. **親コンポーネントで配列を作成**  
   - 複数のオブジェクト（例：`{id:1, name:"三苫"}`など）を持つ配列`members`を定義。

2. **親から子へ配列を渡す**  
   - `<ChildComponent members={members} />` のようにプロップスとして渡す。

3. **子コンポーネントで受け取りと表示**  
   - `props`引数で受け取り、`console.log(props)`で配列の中身を確認。  
   - 例えば`props.members[0].name`で配列の0番目の名前を取得し表示可能。

4. **複数要素をリスト表示**  
   - `<ul>`タグの中で、`props.members.map(member => (<li key={member.id}>{member.name}</li>))` のように記述しリストを作成。  
   - `key`属性はReactの繰り返し要素で必須。

---

## ポイント

- 配列のインデックスは0始まりなので注意。  
- 配列の中身を展開する時は`map`メソッドが便利。  
- リスト要素には必ず`key`属性を指定する。  
- 親から複雑なデータ構造を渡せるので、柔軟な表示が可能。

---

## 実行確認

- ブラウザで表示すると、配列のメンバー3人分の名前がリスト形式で表示される。

---

# 24. propsで配列を渡す (子コンポーネントを繰り返すパターン)

---

## 概要

- 配列を子コンポーネントに丸ごと渡し、子側で`map`を使って展開するパターンの他に、  
- 親コンポーネント側で配列を`map`で展開し、子コンポーネントを複数回繰り返して表示するパターンもある。

---

## サンプルの流れ

1. **子コンポーネントの作成**  
   - `Member`や`MemberList`など任意の名前の関数コンポーネントを用意し、`props`でデータを受け取る。

2. **親コンポーネントで配列を展開**  
   - 親コンポーネントで`members.map(member => <Member name={member.name} key={member.id} />)` のように記述し、配列の要素ごとに子コンポーネントを生成。

3. **子コンポーネントは受け取ったpropsを表示**  
   - 例えば`<div>{props.name}</div>`で名前を表示。

---

## ポイント

- 親側で配列を展開して子コンポーネントを複数表示することで、  
  子コンポーネントは単一の要素に集中でき、コードが分かりやすくなることが多い。  
- 配列展開には必ず`key`属性を指定し、Reactが要素を特定できるようにすることが重要。  
- 両方のパターン（配列を子に渡して子が展開する方法、親が展開して子を繰り返す方法）を知っておくと開発の幅が広がる。

---

## 実行確認

- ブラウザで表示すると、配列のメンバー3人分が子コンポーネントとしてそれぞれ別々に表示される。  
- ChromeのReact開発ツールのコンポーネントタブを見ると、子コンポーネントが複数回使われているのが確認できる。

---


# 25. propsのデフォルト値

---

## 概要

- propsは親から子へ情報を渡すために使うが、情報を渡さない場合もある。  
- そんなときに子コンポーネントで表示する初期値（デフォルト値）を設定しておく方法を紹介。

---

## デフォルト値の設定方法

- JavaScriptの関数のデフォルト引数機能を利用する。  
- 子コンポーネントの引数で、`{ name = "test" }` のように書くと、親から`name`が渡されなかった場合に `"test"` が使われる。

---

## コード例のポイント

- 親コンポーネントで子コンポーネントを呼び出す際に`name`を渡さなければ、子はデフォルトの`"test"`を表示。  
- 親から`name`を渡すと、その値が優先されて表示される。  
- これにより、propsが渡されない場合のエラーを防止できる。

---

## 実行確認

- ブラウザで表示すると、親から`name`を渡さない場合はデフォルトの`"test"`が表示される。  
- `name`を渡すと、その値が表示される。  
- React開発ツールのprops情報も確認可能。

---

## 補足

- デフォルト値の設定は、propsの安全な利用に役立つので覚えておくと便利。

---


# 26. props.children

---

## 概要

- これまでのpropsは親コンポーネントの開始タグに属性として渡していたが、  
  `props.children` はコンポーネントの開始タグと閉じタグの間に書いた内容を子に渡す仕組み。  
- コンポーネントの間に書いた文章や要素が自動的に `props.children` として子コンポーネントに渡される。

---

## 使い方

- 親コンポーネントの中で子コンポーネントを `<Child>ここに書いた内容</Child>` のように使う。  
- 子コンポーネントは `props.children` で受け取り、表示や操作が可能。  
- 通常のpropsと併用できる（例：`name="伊藤"`）。

---

## 動作確認

- コンソールで `props` を確認すると、`name` と一緒に `children` が含まれている。  
- ブラウザ上に、開始タグと閉じタグの間に書いた内容が表示される。

---

## 補足

- `props.children` はVueのスロット機能に似ている。  
- 文章だけでなく、React要素やコンポーネントも渡せるので柔軟に使える。  
- 今後のサンプルアプリでもよく使う機能なので理解しておくと良い。

---

# 27. useState

---

## 概要

- `useState` はReactのフックの一つで、関数コンポーネントで状態（ステート）を管理するための必須知識。  
- Reactフックは関数コンポーネントでもクラスコンポーネントと同じ機能を使える仕組み。  
- `useState` は関数コンポーネントごとに独自の状態変数を持ち、更新があると画面を自動的に再レンダーする。

---

## 使い方の特徴

- フック名は必ず `use` から始まる。  
- `const [変数, 変数を更新する関数] = useState(初期値);` という形式で書く。  
- 例：  
  ```js
  const [count, setCount] = useState(0);
  ```

- 直接変数を変更しても画面は更新されない。

---

## サンプル構成

- コンポーネントを作成し、
    - `count` と `setCount` を用意し初期値0で状態を管理。
    - ボタンを押すと `handleClick` 関数で `setCount(count + 1)` を呼び状態を更新。
    - 画面に現在の `count` を表示し、ボタン押下でカウントが増える。

---

## 注意点

- CDNでReactを使う場合は `React.useState` と書く必要があるため、
    
    変数に代入して簡単に呼び出せるようにすることが多い。
    
- 状態変数を直接更新すると変更が反映されないため必ず更新関数を使うこと。
- 状態が変わるとReactが自動で再レンダーして最新の値を表示してくれる。

---

## まとめ

- Reactの関数コンポーネントで状態管理するには`useState`が基本。
- 変数と更新用関数をセットで扱い、状態更新は更新関数を使うルールを理解する。
- ボタンなどのイベントと組み合わせて動的にUIを更新できる。

# 28. useState (ステート変数が更新されるタイミング)

---

## 概要

- `useState` の更新関数（例：`setCount`）を呼んだタイミングで状態変数（例：`count`）がすぐに変わるわけではない。  
- 状態変数が更新されるのは、関数コンポーネントが再レンダリング（再描画）されるタイミング。  

---

## 挙動の確認

- コンポーネント内に2箇所 `console.log` を仕込むことで挙動を観察。  
  1. コンポーネントが描画されるタイミングでの状態変数の値表示。  
  2. `setCount` 実行直後に状態変数の値表示。  

- 実際は `setCount` を呼んだ直後の状態変数はまだ更新されておらず、再レンダリング後に値が変わる。

---

## 動作の流れ

1. 初回レンダリング時：状態変数は初期値（例：0）。  
2. ボタンをクリックし、`setCount(count + 1)` を実行。  
3. この段階では状態変数 `count` はまだ更新されず、関数の処理は終了。  
4. React が状態変数の変更を検知し、コンポーネントを再レンダリング。  
5. 再レンダリング時に状態変数 `count` は更新された値（例：1）となる。  
6. そのタイミングで最初の `console.log` が再度実行され、更新後の値を表示。

React

```
const ComponentTest = () => {
    const useState = React.useState // CDNの場合React.useStateで呼び出す
    const [ count, setCount ] = useState(0) // 初期値を定義
    const handleClick = () => {
        setCount(count + 1) // 更新用の関数(ステート変数)
    }
    
    return (<>
        <div>count: { count } </div>
        <button onClick={handleClick}>+1</button>
    </>)
}

```

Vue(OptionAPI)

```
export default {
  data() {
    return {
      count: 0
    }
  },
  methods: {
    handleClick(value) {
      this.count = value;
    }
  }
}

```

Vue(CompositionAPI)

```
const count = ref(0);
// 値を変更する場合
count.value = 1;
```

```
const state = reactive({
  count: 0
});
// 値を変更する場合
state.count = 1;
```

---

## ポイント

- 状態変数の更新は非同期的に行われ、更新関数を呼んだ直後に変数の値は変わらない。  
- 状態変数の最新値を取得したい場合は、再レンダリング後にアクセスする必要がある。  
- Reactの再レンダリングは以下の場合に発生：  
  - 状態（useState）が更新された時  
  - プロップスが変更された時  
  - 親コンポーネントが更新された時

---

## まとめ

- `setState`系の関数を呼んでも状態変数はすぐには更新されない。  
- 状態が変わるとReactがコンポーネントを再レンダリングし、その時に最新の状態値が反映される。  
- この非同期のタイミングを理解してReactの状態管理を扱うことが重要。

---

# 29. useState (更新用関数の中で現在のステート変数の値を取得する)

---

## 概要

- 状態更新関数（例：`setCount`）の中で、現在のステート変数の値を取得したい場合がある。  
- その際は、更新関数にコールバック関数を渡すことで、現在の値を安全に取得できる。

---

## コールバック関数の使い方

```js
setCount(currentCount => {
  console.log(currentCount); // 現在の状態変数の値を取得
  return currentCount + 1;   // 新しい状態値を返す
});
```

- 引数の `currentCount` に最新の状態値が渡される。
- これを使うことで、状態変数の最新値を正確に参照しながら更新可能。

---

## 実例

- `handleClick` 関数内で `setCount` にコールバックを渡し、現在のカウントをコンソール出力。
- コールバック関数の戻り値で状態を更新（例：`currentCount + 1`）。
- ボタンを押すたびにコンソールに現在の値が表示され、状態が正しく増加する。

---

## まとめ

- `useState` の更新関数にコールバック関数を渡すと、最新の状態変数の値を安全に取得できる。
- 複数回連続して状態更新を行う場合や、状態の最新値に依存する更新処理に有効。
- Reactの状態更新は非同期なので、この方法で確実に現在の値を使うことが推奨される。

# 30. 子から親のstateを操作する方法

---

## 概要

- Reactでは「子コンポーネントから親コンポーネントのstateを操作」したいケースがある。  
- 直接子から親のstateを変更できないため、親から子に「stateを更新する関数」をpropsで渡し、子がその関数を呼び出す形で実現する。

---

## 実装方法

1. **親コンポーネント**  
   - `useState`でstate（例：`count`）を定義。  
   - stateを更新する関数（例：`handleClick`）を作成。  
   - 子コンポーネントにpropsとして更新関数（`handleClick`）を渡す。

2. **子コンポーネント**  
   - propsで親から渡された更新関数を受け取る。  
   - ボタンのクリックイベントなどでその関数を呼び出し、親のstateを間接的に更新する。

---

## コード例

```jsx
// 親コンポーネント
const Parent = () => {
  const [count, setCount] = useState(0);
  const handleClick = () => setCount(count + 1);

  return (
    <>
      <p>親のカウント: {count}</p>
      <Child handleClick={handleClick} />
    </>
  );
};

// 子コンポーネント
const Child = (props) => {
  return (
    <button onClick={props.handleClick}>
      子コンポーネントのボタン +1
    </button>
  );
};
```

## 動作確認

- 親の画面にカウントが表示される。
- 子のボタンを押すと、親の`count`が1ずつ増加。
- React Developer Toolsなどで、親のstateが正しく更新されていることを確認できる。

---

## ポイント

- 子は親のstateを直接変更できないため、親の更新関数をpropsで渡し、子はその関数を呼ぶだけ。
- Reactの単方向データフロー（親→子）を守りつつ、子から親へイベントを伝達できる標準的な方法。
- これにより、コンポーネント間の状態管理がシンプルに保たれる。

# 31. セクション2のまとめ

---

## セクション2のポイント

- Reactはコンポーネント（部品）を使って画面を描画する。  
- React Hooksの登場により、関数コンポーネントが主流になっている。  
- 今後の講座でも関数コンポーネントでの書き方に慣れていく。  
- 親コンポーネントから子コンポーネントへ情報を渡すには`props`を使う。  
- コンポーネントごとに変数を持たせるには`useState`フックを使用する。  
- `useState`で定義したstateを更新すると、そのタイミングでコンポーネントが再レンダリングされる。  

---

## 次のステップ

- 次のセクションでは、これまで紹介した機能を使って簡単なサンプルを複数作成していく。  
- 引き続き次のセクションへ進んで学習を続ける。

---
