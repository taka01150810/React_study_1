# 41. Reactのフォームの概要

---

## フォームの種類

- **同期フォーム**  
  - 画面を更新しながらサーバーにデータ送信  
  - `<form>`タグを使い、`GET`や`POST`メソッドで送信  
  - サーバー側（例：PHP）で処理  

- **非同期フォーム（AJAX）**  
  - 画面更新なしで裏側でデータ送信  
  - JavaScript（＋XML）で実装  
  - `<form>`タグを使わなくてもよい  
  - `GET`や`POST`だけでなく`PUT`、`PATCH`、`DELETE`なども利用可能  

---

## フォームの基本構造

- `<form>`タグの中に様々な入力タグがある  
  - `<input>`（テキスト、ラジオボタン、チェックボックスなど）  
  - `<textarea>`（複数行テキスト）  
  - `<select>`（ドロップダウン）  
  - `<button type="submit">`（送信ボタン）  
- `<input>`には`name`と`value`属性があり、サーバーへはキーと値のペアで送信される  
- MozillaのMDNにフォームの詳細な説明ページあり  

---

## Reactでのフォーム作成

- フォームは複雑になりがちなので専用ライブラリ（例：React Hook Form）があるが、本セクションでは使用しない  
- 作り方は大きく分けて2種類  
  1. **制御コンポーネント**（Controlled Components）  
     - Reactの`useState`で値を管理  
     - 複雑なフォームに対応可能  
     - React推奨の方法  
  2. **非制御コンポーネント**（Uncontrolled Components）  
     - `useRef`を使ってDOMに直接アクセス  
     - HTMLに近い動き  
     - ファイルアップロードなど一部の場面で利用  
- パフォーマンス問題があれば、`useReducer`に切り替える方法もある  

---

## 参考情報

- React公式マニュアルにもフォーム関連の解説あり  
- 制御・非制御コンポーネントの両方が紹介されている  
- 今後、`useRef`を使った非制御コンポーネントの説明も予定  
- 今セクションは基本的に`useState`を使った制御コンポーネントの方法で進める予定  

# 42. useState(制御コンポーネント)で簡単なフォームをつくる

---

## 概要

- Reactで制御コンポーネントを使い、簡単なフォームを作成する
- AJAX送信の場合、`<form>`タグはあってもなくても良いが、範囲が分かりやすいため使用する
- フォームはラベル、インプット、ボタンの3つのタグで構成

---

## 主なポイント

### ラベル

- `<label>`タグは`htmlFor`属性でインプットの`id`と紐付ける（`for`ではなく`htmlFor`と書く）

### インプット

- `id`と`name`はラベルと同じ名前にする  
- `type="text"`  
- `value`にReactの`useState`で管理する状態変数をセット  
- `onChange`イベントで入力値を取得し、状態を更新する関数を呼ぶ  
- イベントオブジェクトの`event.target.value`から入力値を取得して`setName`関数で更新  

### ボタン

- `<button>`はデフォルトで`type="submit"`  
- フォームの送信イベントは`onSubmit`で受け取る  
- 送信時に`event.preventDefault()`を呼び画面リロードを防ぐ  
- 送信イベント内で`console.log`でイベント情報を表示して確認  

---

## 実装の流れ

1. Reactの`useState`で`name`と`setName`を定義し、初期値は空文字  
2. JSXの`<form>`内に`<label>`（`htmlFor="name"`）、`<input>`（`id="name"`、`name="name"`、`value={name}`、`onChange={handleChange}`）、`<button>`を配置  
3. `handleChange`関数は引数でイベントを受け取り、`setName(event.target.value)`で状態更新  
4. `handleSubmit`関数は送信イベントを受け取り、`event.preventDefault()`でページリロードを防止し、イベント情報を`console.log`に表示  
5. フォームの入力をリアルタイムに状態で管理し、送信ボタン押下時も画面遷移せずに動作を確認  

---

## 動作確認

- 入力欄に文字を入力すると`name`ステートがリアルタイムで更新される  
- 送信ボタンを押すと画面はリロードされず、イベント情報がコンソールに表示される  
- `event.preventDefault()`をコメントアウトすると、送信時にページがリロードされることを確認可能  

---

## まとめ

- Reactの`useState`を使った制御コンポーネントで基本的なフォームが作れる  
- 画面更新なしで送信イベントを処理するには`event.preventDefault()`が必須  



# 43. useStateでオブジェクトを使う方法

---

## 概要

- Reactの`useState`でオブジェクトを状態管理する方法を紹介
- フォーム入力が複数ある場合に便利
- 初期値として名前(`name`)とメール(`email`)を空文字で持つオブジェクトを設定

---

## 実装ポイント

### JSX内の変更点

- インプットの`value`は単一の値からオブジェクトのプロパティ（例: `form.name`）へ変更
- インプットの`name`属性を使って入力項目を区別し、同じ`handleChange`関数で複数入力を処理

### handleChange関数

- イベントオブジェクトから`target`の`name`と`value`を分割代入で取得
- `setForm`で状態を更新する際にスプレッド構文（`...form`）で既存の状態を展開し、  
  `[name]: value`で該当フィールドだけを上書き  
- プロパティ名を変数で指定するため、角括弧で囲む（例: `[name]`）

### handleSubmit関数

- 送信時に`event.preventDefault()`で画面リロードを防止
- コンソールに送信イベントを表示

---

## 動作確認

- 複数の入力フォーム（名前とメール）を同時に管理・更新できる
- 入力中にそれぞれの状態がリアルタイムで更新されていることがReact DevToolsなどで確認可能
- 送信ボタン押下でフォーム送信イベントが捕捉され、画面は更新されない

---

## まとめ

- 入力項目が複数あるフォームは、単一の状態変数にオブジェクトとしてまとめて管理すると便利
- スプレッド構文と変数名を使った動的プロパティ指定が重要なテクニック
- 実践的なフォーム処理の基礎となるため、しっかり理解しながら手を動かして学ぶことを推奨

# 44. フォーム: textarea, radioボタン

---

## 概要

- Reactの`useState`を使ってお問い合わせフォームを作成
- テキストエリア、ラジオボタン、SELECTボックス、チェックボックスなど複数のフォーム要素を扱う
- ここでは特にテキストエリアとラジオボタンの書き方にフォーカス

---

## テキストエリアのポイント

- HTMLのテキストエリアはタグの中に値を書く仕様だが、Reactでは`value`属性で値を指定する必要がある
- Reactでの`value`は`form.contact`などステートの該当プロパティを指定
- `onChange`イベントで入力内容をリアルタイムに更新

---

## ラジオボタンのポイント

- 性別(`gender`)を3択（Male, Female, Other）で実装
- 各ラジオボタンに`label`タグを使い、`htmlFor`属性と対応する`input`の`id`を合わせて紐づける
- `name`属性はすべて共通（`gender`）にして、1つだけ選択できるようにする
- `value`属性はそれぞれ`male`、`female`、`other`と文字列で指定
- `onChange`はテキスト入力と同じ`handleChange`関数を使って更新

---

## 実装の流れ

- `useState`のオブジェクトに`gender`と`contact`（お問い合わせ内容）を追加
- JSX内に`label`、`textarea`、`input type="radio"`を適切に配置
- 改行タグ(`<br>`)を使い見やすくレイアウト調整
- `handleChange`関数はそのまま再利用し、`event.target.name`でどの入力か判別して状態更新

---

## 動作確認

- テキストエリアに文字入力すると`form.contact`の状態がリアルタイム更新
- ラジオボタンで選択肢を変えると`form.gender`の状態が切り替わる
- React DevToolsなどで状態変化を確認可能

---

## まとめ

- テキストエリアは`value`属性の指定がHTMLと異なる点に注意
- ラジオボタンは複数の選択肢のうち1つを選ばせるため`name`を共通にする
- `useState`のオブジェクトに複数のフォーム値を持ち、1つの`handleChange`で効率的に管理可能
- これにより入力ごとにリアルタイムで状態を更新し、バリデーションや送信処理に活用できる


# 45. フォーム: selectボックス

---

## 概要

Reactで`useState`を使ってフォームを作成する中で、今回は **セレクトボックス（select要素）** を扱います。  
年齢（年代）を選択できるフォームとして実装していきます。

---

## セレクトボックスの基本構造

- `<select>` タグの中に `<option>` を複数入れる
- HTMLと同様の構造だが、Reactでは以下の点が異なる:
  - `value` 属性で選択状態を制御（ステートと同期）
  - オプションを配列＋`map()`で動的生成可能
  - `onChange`で状態更新

---

## 実装ポイント

### 1. ステートの初期化

```js
const [form, setForm] = useState({
  age: ""
});
```

### 2. 年代リストの用意（配列）

```jsx
js
コピーする編集する
const ages = [
  { id: 0, generation: "10代" },
  { id: 1, generation: "20代" },
  { id: 2, generation: "30代" },
  { id: 3, generation: "40代" },
  { id: 4, generation: "50代" },
  { id: 5, generation: "60代" },
  { id: 6, generation: "70代以上" }
];

```

---

### 3. JSX内でのフォーム記述

```jsx
jsx
コピーする編集する
<label htmlFor="age">年齢</label><br />
<selectid="age"
  name="age"
  value={form.age}
  onChange={handleChange}
>
  {ages.map((age) => (
    <option key={age.id} value={age.id}>
      {age.generation}
    </option>
  ))}
</select>

```

---

### 4. イベントハンドラ（共通）

```jsx
js
コピーする編集する
const handleChange = (e) => {
  setForm({
    ...form,
    [e.target.name]: e.target.value
  });
};

```

---

## 動作確認の流れ

- セレクトボックスで年代を選ぶと、`form.age`に対応する`id`が格納される（例: 20代→1）
- `console.log(form)`で現在のフォーム内容を確認可能
- 年代の選択が正しくステートに反映されていればOK

---

## 応用のヒント

- 都道府県、職業カテゴリなど選択肢が多いUIにおいても`select + map()`の構成は有効
- `option`のvalueを文字列ではなくIDにすることで、内部処理がしやすくなる

---

## まとめ

- Reactの`select`は`value`と`onChange`を使ってステートと連携する
- 複数の選択肢は配列 + `map()` で動的生成可能
- フォームの値は一元管理し、送信時などに活用できる

# 46. フォーム: チェックボックス（boolean）

---

## 概要

お問い合わせフォームに **チェックボックス** を追加。  
今回は **1つのチェックボックスをブーリアン（true/false）** で制御するパターンを解説します。

---

## ポイント

- チェック状態は `true / false` のブーリアン型で管理。
- `e.target.checked` を使うことで、チェックの状態を取得。
- `e.target.value` では常に `"on"` が返るため不適切。

---

## ステート初期化

```js
const [form, setForm] = useState({
  caution: false
});
```

## チェックボックスのJSX

```jsx
jsx
コピーする編集する
<input
  type="checkbox"
  name="caution"
  onChange={handleChange}
/>
<label htmlFor="caution">注意事項に同意する</label>

```

---

## ハンドラ関数（handleChange）

```jsx
js
コピーする編集する
const handleChange = (e) => {
  const name = e.target.name;
  const value = name === "caution" ? e.target.checked : e.target.value;

  setForm({
    ...form,
    [name]: value
  });
};

```

---

## 動作確認

- 初期状態：`caution = false`
- チェック → `true`
- チェックを外す → `false`
- 送信時には `form` オブジェクトに現在の状態が反映される

```jsx
js
コピーする編集する
// 例: 送信ボタンクリック時
console.log(form);
// { caution: true } または { caution: false }

```

---

## 補足

- `e.target.checked` は `boolean` を返すため、ブーリアン値の取得に最適。
- `e.target.value` は `"on"` しか返さないため、チェック状態の判断には使用しない。

---

## まとめ

- Reactでチェックボックスを扱う際は、`checked` を使って状態を取得する
- `name`によってブーリアンか通常の値かを判定し、値をセットする
- シンプルなチェックボックス1個の実装にはこの方式が有効

# 47. checkボックス（複数・useStateで配列を扱う）

## 概要

チェックボックスが複数ある場合、React の `useState` で配列を扱う方法について学習します。配列を直接変更するのではなく、「**新しい配列を作って state を更新する**」必要があります。

## なぜ新しい配列が必要？

`useState` は内部で `Object.is` によって前回と現在の値の比較をしており、**破壊的変更（push/splice等）**では変更とみなされないため再レンダリングが起きません。

そのため、**スプレッド構文（`...`）** や **filter関数** を用いて「新しい配列オブジェクト」を作る必要があります。

## 実装例：興味がある項目（複数回答）

```jsx
jsx
コピーする編集する
const [form, setForm] = useState({
  kyomies: [],
});

const handleChange = (e) => {
  const { name, value } = e.target;
  if (form.kyomies.includes(value)) {
    // 値が既に含まれている → 削除する
    const newList = form.kyomies.filter((item) => item !== value);
    setForm({ ...form, [name]: newList });
  } else {
    // 値が含まれていない → 追加する
    const newList = [...form.kyomies, value];
    setForm({ ...form, [name]: newList });
  }
};

```

## チェックボックス例

```jsx
jsx
コピーする編集する
<label>
  <inputtype="checkbox"
    name="kyomies"
    value="スポーツ"
    onChange={handleChange}
  />
  スポーツ
</label>

<label>
  <inputtype="checkbox"
    name="kyomies"
    value="ニュース"
    onChange={handleChange}
  />
  ニュース
</label>

<label>
  <inputtype="checkbox"
    name="kyomies"
    value="IT"
    onChange={handleChange}
  />
  IT
</label>

```

## 送信例（ログ出力）

```jsx
jsx
コピーする編集する
const handleSubmit = (e) => {
  e.preventDefault();
  console.log(form);
};

```

## 注意点

- `useState` の配列操作では、**既存の配列を直接変更しない**。
- `push()` や `splice()` は **破壊的操作** のため、Reactの再レンダリングが発生しない。
- 常に新しい配列を作るようにする（`[...]`, `.filter()`）。

## 参考リンク

React公式ドキュメント - useState

# 48. useRef のパターン（Uncontrolled Component）

## 🔍 概要

これまで扱ってきた `useState` を使ったフォームは「**制御コンポーネント（Controlled Component）**」でした。ここでは、`useRef` を用いた「**非制御コンポーネント（Uncontrolled Component）**」の書き方を学びます。

特にファイルアップロードなどは、非制御コンポーネントでないと正しく扱えないケースがあります。

---

## 💡 useRef の特徴

| 特徴 | 内容 |
| --- | --- |
| DOM参照 | HTML要素を直接参照できる（リファレンス） |
| 非リアクティブ | 値を変更しても再レンダリングされない |
| パフォーマンス | `useState` よりもパフォーマンスが良いケースもある |
| 使用用途 | 入力フォーム（ファイル等）、スクロール位置取得など |

---

## 📌 DOMとは？

- DOM（Document Object Model）は HTML を**木構造**で表現したもの。
- JavaScript で HTML を操作しやすくするための概念。
- `useRef` は、この DOM にアクセスするための手段。

---

## 🧪 実装例（テキストフォーム）

```jsx
jsx
コピーする編集する
import React, { useRef } from 'react';

const UncontrolledForm = () => {
  const nameRef = useRef(null); // 初期値は null

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(nameRef.current.value); // 入力値を取得
  };

  return (
    <><h2>Uncontrolled Form</h2>
      <form onSubmit={handleSubmit}>
        <inputtype="text"
          name="name"
          ref={nameRef}
          placeholder="お名前を入力"
        />
        <button type="submit">送信</button>
      </form>
    </>
  );
};

```

---

## ✅ ポイントまとめ

- `useRef` は `React.useRef()` で初期化し、DOM 要素に `ref` 属性で渡す。
- `.current.value` でユーザー入力を取得。
- `useState` とは異なり、文字入力しても再レンダリングが発生しない。
- 非制御コンポーネントは、**リアルタイムの状態管理が不要な場合**や**ファイルアップロード**に便利。

---

## 🧪 再レンダリング比較

```jsx
jsx
コピーする編集する
console.log('レンダリング'); // useStateと違って再レンダリングされない

```

---

## 📦 使い所

- 入力を取得するタイミングが「ボタンを押した時」など、イベントに依存するケース。
- `input type="file"` のようなファイル系フォーム。
- パフォーマンスを意識したフォーム設計。

---

## 🔗 参考リンク

- React公式: 非制御コンポーネント
- MDN: Document Object Model (DOM)

---

次回は、この `useRef` を活用して「画像アップロードフォーム」の実装を学びます。


# 49. フォーム: ファイルアップロード (非制御)

## 概要

Reactでファイルアップロード機能を実装する方法として、`useRef`を使った**非制御コンポーネント**の例を解説。

## 主なポイント

- `useRef`を使って、`<input type="file">`要素にアクセス。
- フォーム送信時にファイル情報を取得。
- HTMLのお約束として、`<form>`タグには `encType="multipart/form-data"` を指定。

## サンプルコード概要

```tsx
tsx
コピーする編集する
import { useRef } from "react";

function App() {
  const fileInput = useRef<HTMLInputElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (fileInput.current?.files) {
      const file = fileInput.current.files[0];
      console.log(file.name); // ファイル名を出力
    }
  };

  return (
    <form onSubmit={handleSubmit} encType="multipart/form-data">
      <input type="file" ref={fileInput} />
      <button type="submit">送信</button>
    </form>
  );
}

```

## 解説ポイント

- `input type="file"` に `ref={fileInput}` を指定。
- `encType="multipart/form-data"` は画像などのバイナリデータ送信時に必要。
- `fileInput.current.files[0]` で最初に選択されたファイルを取得。
- `.name` プロパティでファイル名を取得可能。

## 動作確認

1. 画像などのファイルを選択。
2. 「送信」ボタンをクリック。
3. コンソールにファイル名（例: `image001.jpg`）が表示される。

## 備考

- `.files` は`FileList`オブジェクトなので、複数ファイルのアップロードにも対応。
- 今回は非制御方式だが、制御コンポーネントとの違いも併せて学ぶと理解が深まる。

---

# 50. サンプル4: ToDoリストその1 - 追加機能

## 概要

Reactを使ってシンプルなToDoリストアプリを作成。

このパートでは「タスクの追加機能」のみを実装。

---

## 完成イメージ

- 入力ボックスに文字を入力
- 「追加」ボタンでリストにアイテムを追加
- チェックボックスや削除機能は次のステップで対応

---

## 実装ポイント

- **useState** を使用して以下の状態を管理:
    - `item`: 入力ボックスの現在の値
    - `todos`: ToDoリスト（オブジェクトの配列）
- `todos`の要素はオブジェクト形式：
    
    ```tsx
    ts
    コピーする編集する
    {
      item: string,
      isDone: boolean // 完了フラグ（初期はfalse）
    }
    
    ```
    
- ToDoの追加は **スプレッド構文** を使って配列を更新。

---

## コード概要

```jsx
jsx
コピーする編集する
const { useState } = React;

function TodoList() {
  const [item, setItem] = useState('');
  const [todos, setTodos] = useState([
    { item: 'サンプルタスク', isDone: false }
  ]);

  const addItem = () => {
    if (!item) return; // 空文字の追加は防止

    const newTodo = {
      item,
      isDone: false
    };

    setTodos([...todos, newTodo]);
    setItem(''); // 入力ボックスをリセット
  };

  return (
    <><inputtype="text"
        value={item}
        onChange={(e) => setItem(e.target.value)}
      />
      <button onClick={addItem}>追加</button>

      <ul>
        {todos.map((todo, index) => (
          <li key={index}>{todo.item}</li>
        ))}
      </ul>
    </>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TodoList />);

```

---

## 補足

- `!item` によるチェックで空文字の追加を防止。
- `map()`でリストを動的にレンダリング。
- このセクションは「追加機能」まで。チェックと削除は次のセクションで実装。

---

## 次のステップ

- チェック機能（完了タスクに打ち消し線）
- 削除機能（個別のタスクを削除）

# 51. ToDoリストその2 削除機能

## 🔧 今回の目的

ToDoリストに「削除機能」を追加する。

---

## 📝 実装手順

### 1. ToDoリストの表示（`map()`を使ってリスト表示）

- `ul`タグでリスト全体を囲む。
- `todos.map((todo, index) => (...))` でリストを展開。
    - 第2引数の `index` を使ってアイテムのインデックスを取得。
- 各アイテムの構造は以下の通り：

```tsx
tsx
コピーする編集する
<ul>
  {todos.map((todo, index) => (
    <li key={index}>
      <input type="checkbox" />
      <span>{todo.item}</span>
      <button onClick={() => deleteItem(index)}>削除</button>
    </li>
  ))}
</ul>

```

---

### 2. CSSの設定

- `ul` のデフォルトの「丸ポチ（list-style）」を消す。

```css
css
コピーする編集する
ul {
  list-style: none;
}

```

- このスタイルは `<head>` タグ内の `<style>` に追加。

---

### 3. 削除関数の実装

```tsx
ts
コピーする編集する
const deleteItem = (id: number) => {
  const newList = todos.filter((_, index) => index !== id);
  setTodos(newList);
};

```

- `filter()` を使って、新しい配列 `newList` を作成。
    - `id`（削除対象のインデックス）と一致しない要素だけを残す。
- `setTodos(newList)` で state を更新。

---

## ✅ 動作確認方法

1. ブラウザでToDoを複数追加。
2. 特定の削除ボタンを押す。
3. 対象のToDoが正しく削除されるかを確認。

---

## 💡 補足ポイント

- `map()`や`filter()`で第2引数を使うことで、配列のインデックスを扱える。
- `key={index}` は簡易的な方法で、将来的には一意のIDの使用を検討するのがベター。
- チェックボックスは今後の実装対象。

# 52. ToDoリストその3 チェックボックス機能

## ✅ 今回の目的

ToDoリストに **チェックボックスを付けて、チェック時に横線（取り消し線）を表示** する機能を追加する。

---

## 🔧 実装手順

### 1. `span` にクラスを付けて横線を表示

- チェックされたアイテムにだけ `"done"` クラスを付ける。

```tsx
tsx
コピーする編集する
<span className={todo.isDone ? "done" : ""}>
  {todo.item}
</span>

```

- CSS側で横線を表示するクラス `.done` を設定：

```css
css
コピーする編集する
.done {
  text-decoration: line-through;
}

```

---

### 2. チェックボックスにチェック状態を反映・制御

- `input`タグに以下を設定：

```tsx
tsx
コピーする編集する
<input
  type="checkbox"
  checked={todo.isDone}
  onChange={(e) => handleChange(index, e)}
/>

```

- `checked` 属性で状態を表示。
- `onChange` イベントで状態を更新。

---

### 3. 状態更新の関数 `handleChange` を作成

```tsx
ts
コピーする編集する
const handleChange = (id: number, e: React.ChangeEvent<HTMLInputElement>) => {
  const newList = todos.map((todo, index) => {
    if (index === id) {
      return {
        ...todo,
        isDone: e.target.checked,
      };
    }
    return todo;
  });

  setTodos(newList);
};

```

- `map()` を使って新しい配列を作成。
- 指定インデックス（id）の `isDone` を `true/false` に更新。
- `setTodos()` で state を更新。

---

## 🧪 動作確認方法

1. ブラウザでToDoを複数追加。
2. チェックボックスをオンにする。
3. 該当のToDoに横線が付けばOK。
4. チェックを外すと横線が消えるかを確認。

---

## 💡 補足ポイント

- チェックボックスの `onChange` で `e.target.checked` を使って真偽値を取得。
- `isDone` フラグに応じて表示（UI）を変えるという典型的な React のパターン。
- これまで学んだ `useState`, `map`, `event handling` を統合して応用。

---

## 🏁 まとめ

- チェックボックスによる状態変更の仕組みを実装。
- 状態に応じて CSS を切り替えることで、視覚的な変化（横線）を実現。
- 削除機能との組み合わせで、ToDoリストが実用的なアプリに近づいた。

# 53. セクション4のまとめ

## 🧾 セクションの概要

このセクションでは、**フォーム（入力）とToDoリストの状態管理**について学びました。

---

## ✏️ フォーム入力の扱い

- フォーム入力の制御には **`useState`** を使う。
- 入力フォームは「**制御コンポーネント（Controlled Component）**」として扱う。
- 入力値を **リアルタイムにStateで管理・更新** するのが基本。

---

## 📎 もう一つの手段：`useRef`

- ファイルアップロードや、リッチなワープロ系のフォーム入力には **`useRef`** を使うパターンもある。
- `useState`と`useRef`の使い分けが重要。

---

## 📚 配列の状態更新

- `useState`で配列を扱う場合は、**新しい配列を作ってから更新**する必要がある。
    - 例：`setTodos([...todos, newTodo])`
- 既存の配列を直接変更するのではなく、**イミュータブル（非破壊）な操作**が原則。

---

## ✅ 実装例：ToDoリスト

- 入力 → 追加 → 表示 → チェック（横線） → 削除 の一連の操作を実装。
- **実践的なフォームの操作パターン**を学んだ。

---

## 🔍 次への予告

- 今後、**検索機能**の追加を予定。
- その際には新たに **`useEffect`フック** を活用する。
- 次のセクションで詳しく解説。

---

## 🏁 まとめ

- `useState` を使ったフォーム制御の基本を理解。
- 状態の扱い（特に配列やチェックボックス）の重要ポイントを整理。
- 実際のToDoリストでReactの状態管理の力を体感。
- 次セクションでは「検索機能」＋「useEffect」に進む。
